import "regenerator-runtime/runtime";
import "core-js";
import React from "react";
import ReactDOM from "react-dom";
import componentsLoader from "./autogenerated-components-loader";

const CAN_LAZILY_HYDRATE = "IntersectionObserver" in window;

function generateHydrationMarkersMap() {
  const markerHeaderSubstring = "__ELEVENTY_REACT_HYDRATION_MARKER__:";
  const nodeIterator = document.createNodeIterator(
    document.body,
    NodeFilter.SHOW_COMMENT,
    {
      acceptNode(node) {
        return node.textContent.startsWith(markerHeaderSubstring)
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_REJECT;
      },
    }
  );
  const markers = {};
  let currentNode;

  while ((currentNode = nodeIterator.nextNode())) {
    let data;
    try {
      const rawJSON = currentNode.textContent.replace(
        markerHeaderSubstring,
        ""
      );
      data = JSON.parse(rawJSON);
    } catch {
      console.error("Unable to parse JSON data");
    }

    if (!markers[data.id]) {
      markers[data.id] = {};
    }

    markers[data.id][data.loc] = {
      node: currentNode,
      data,
    };
  }

  return markers;
}

function hydrateComponent(
  Component,
  markerNode,
  serializedProps,
  componentNodes
) {
  // Hydrate the Component in a separate container in case it has siblings.
  const containerEl = document.createElement("div");
  containerEl.append(...componentNodes);
  const props = JSON.parse(serializedProps);
  ReactDOM.hydrate(<Component {...props} />, containerEl);
  markerNode.replaceWith(...containerEl.children);
  containerEl.remove();
}

(async () => {
  const componentCache = {
    _cache: new Map(),

    async get(name) {
      if (this._cache.has(name)) {
        return this._cache.get(name).default;
      }

      const component = await componentsLoader[name]();
      this._cache.set(name, component);

      return component.default;
    },
  };
  const markers = generateHydrationMarkersMap();
  const lazyHydrateMap = new WeakMap();
  let observer;

  await Promise.all(
    Object.values(markers).map(async ({ start, end }) => {
      const { componentName, props: serializedProps, lazy = true } = start.data;

      const startMarkerNode = start.node;
      const endMarkerNode = end.node;
      const componentNodes = [];
      let nodeToCheck = startMarkerNode.nextSibling;
      while (nodeToCheck !== endMarkerNode) {
        componentNodes.push(nodeToCheck);
        nodeToCheck = nodeToCheck.nextSibling;
      }
      endMarkerNode.remove();

      if (CAN_LAZILY_HYDRATE && lazy) {
        if (!observer) {
          observer = new IntersectionObserver(
            async (entries, observerInstance) => {
              for (const { intersectionRatio, target } of entries) {
                // Will be executed when instantiated. Guard against prematurely
                // hydrating components who aren't in the viewport.
                if (intersectionRatio === 0) {
                  continue;
                }

                const {
                  componentName,
                  startMarkerNode,
                  serializedProps,
                  componentNodes,
                } = lazyHydrateMap.get(target);
                console.log("Hydrated lazily: " + componentName);

                hydrateComponent(
                  await componentCache.get(componentName),
                  startMarkerNode,
                  serializedProps,
                  componentNodes
                );

                observerInstance.unobserve(target);
              }
            }
          );
        }

        // IntersectionObserver requires that the node being observed is an Element.
        const markerEl = componentNodes.find((node) => node instanceof Element);
        lazyHydrateMap.set(markerEl, {
          componentName,
          startMarkerNode,
          serializedProps,
          componentNodes,
        });
        observer.observe(markerEl);
        return;
      }

      hydrateComponent(
        await componentCache.get(componentName),
        startMarkerNode,
        serializedProps,
        componentNodes
      );

      console.log("Hydrated normally: " + componentName);
    })
  );
})().catch((err) =>
  console.error(`Could not hydrate interactive components. Error: ${err}`)
);
